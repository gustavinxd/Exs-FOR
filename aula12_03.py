# -*- coding: utf-8 -*-
"""Aula12/03.pynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14bi8xcTsC7BLF2n7N_18Q4Pboq5gj_8Z
"""

def calculadora(operador):
  def operacao(a,b):
    return eval(f'{a} {operador} {b}')

  return operacao

soma = calculadora('+')
print(soma(5,3))

sub = calculadora('-')
print(sub(10,4))

mult = calculadora('*')
print(mult(6,7))

div = calculadora('/')
print(div(20,4))

def fatorial(n):
  if n == 1:
    return 1
  return n * fatorial(n - 1)

print(fatorial(5))

def potencia(base,expoente):
  if expoente == 0:
    return 1
  return base * potencia(base,expoente-1)

print(potencia(2,3))

celsius_para_fahrenheit = lambda x: x*1.8 + 32

print(celsius_para_fahrenheit(0))
print(celsius_para_fahrenheit(21))
print(celsius_para_fahrenheit(100))

max = lambda a,b: a if a > b else b

print(max(1,2))

def decorador(funcao):
  def wrapper():
    print('antes da chamada da função')
    funcao()
    print('depois da chamada da função')
  return wrapper

@decorador
def minha_funcao():
  print('Funçao decorada')

minha_funcao()

"""A seguinte expressão pode aproximar quanto se
queira seu resultado ao número π = 3,141592653 ...:
π = 4 × (1 −
1
3
+
1
5
−
1
7
+
1
9
−
1
11 + ⋯ )

Implemente em Python a função estima_pi(n), que
retorna uma aproximação para o valor de π, onde n
é o número de parcelas (entre os parênteses) usadas
no cálculo. Cheque seus resultados com a tabela
dada. Nota: use boa prática e inclua documentação
com docstrings.
"""

def estima_pi(n):

  den = [1/((2*x+1)*(-1)**x) for x in range(n)]

  return 4*sum(den)

estima_pi(100000)

def estima_pi(n):

  soma = 0
  for x in range(n):
    den = 1/((2*x+1)*(-1)**x)
    soma += den

  return 4*soma

estima_pi(2)

def raiz(N):
  '''
  Calcula a raiz quadrada de N
  Usando o algoritmo:
  x_(n+1) = 1/2 * (x_n + N/x_n)
  '''
  if N == 0 or N == 1:
    return N
  if N < 0:
    N = -N

  x = 1
  while abs(x*x - N) > 1e-9:
    x = 1/2 * (x + N/x)

  return x

raiz(9)

def pitagoras(a,b):
  return raiz(a**2 + b**2)

pitagoras(3,4)

def eqgrau2(a,b,c):
  '''
  Resolve:
  a * x**2 + b * x + c = 0
  '''
  delta = b**2 - 4 * a * c
  if delta < 0:
    print(f'Delta ({delta}) é menor do que zero!')
    return None
  rdelta = raiz(delta)
  x1 = (-b - rdelta) / (2 * a)
  x2 = (-b + rdelta) / (2 * a)
  return x1, x2

# (x - 2)*(x - 3) = 0 tem raizes 2 e 3
# x**2 - 5 * x + 6 = 0
# a = 1, b = -5, c = 6
a, b, c = 1, -5, 6
eqgrau2(a,b,c)

a, b, c = 10, 1, 1
eqgrau2(a,b,c)

def soma_recursiva(n):
  if n <= 0:
    return 0
  return n + soma_recursiva(n - 1)

def soma_iterativa(n):
  soma = 0
  for i in range(1,n + 1):
    soma += i
  return soma

print(soma_recursiva(0))
print(soma_recursiva(-3))
print(soma_recursiva(1))
print(soma_recursiva(100))
print(soma_iterativa(100))

def fibonacci(n):
  if n <= 2:
    return 1
  return fibonacci(n - 1) + fibonacci(n - 2)

lista_f = [fibonacci(n) for n in range(1,8)]
print(lista_f)